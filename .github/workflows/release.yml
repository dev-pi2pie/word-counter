name: Release

on:
  push:
    tags:
      - "*"
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag to release (e.g. v1.2.3)"
        required: true
        type: string
      shallow_since:
        description: "Optional shallow fetch cutoff date (YYYY-MM-DD) for branch validation; leave blank to unshallow."
        required: false
        type: string

jobs:
  notes:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
    outputs:
      tag: ${{ steps.tag.outputs.tag }}
      prerelease: ${{ steps.prerelease.outputs.IS_PRERELEASE }}
      release_notes: ${{ steps.notes.outputs.content }}
      previous_tag: ${{ steps.range.outputs.previous_tag }}
      release_range: ${{ steps.range.outputs.range }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          # Keep checkout light; branch validation will deepen/unshallow if needed.
          fetch-depth: 1
          ref: ${{ inputs.tag && format('refs/tags/{0}', inputs.tag) || github.ref }}
          show-progress: false

      - name: Resolve tag
        id: tag
        env:
          TAG_INPUT: ${{ inputs.tag }}
        run: |
          CLEAN_TAG_INPUT=$(printf '%s' "$TAG_INPUT" | tr -d '\r' | xargs)
          if [ -n "$CLEAN_TAG_INPUT" ]; then
            echo "tag=$CLEAN_TAG_INPUT" >> "$GITHUB_OUTPUT"
          else
            echo "tag=${GITHUB_REF#refs/tags/}" >> "$GITHUB_OUTPUT"
          fi

      - name: Ensure tag is on allowed branch
        env:
          SHALLOW_SINCE: ${{ inputs.shallow_since }}
        run: |
          FETCH_DEPTH_ARGS=()
          if [ -n "$SHALLOW_SINCE" ]; then
            FETCH_DEPTH_ARGS=(--shallow-since="$SHALLOW_SINCE")
          elif [ -f .git/shallow ]; then
            git fetch origin --tags --unshallow
          fi

          git fetch origin --tags "${FETCH_DEPTH_ARGS[@]}"
          git fetch origin --no-tags main "${FETCH_DEPTH_ARGS[@]}"
          git fetch origin \
            --no-tags \
            "refs/heads/beta*:refs/remotes/origin/beta*" \
            "refs/heads/alpha*:refs/remotes/origin/alpha*" \
            "refs/heads/canary*:refs/remotes/origin/canary*" \
            "refs/heads/dev*:refs/remotes/origin/dev*" \
            "${FETCH_DEPTH_ARGS[@]}" || true
          TAG_COMMIT=$(git rev-list -n 1 "${{ steps.tag.outputs.tag }}")
          if git merge-base --is-ancestor "$TAG_COMMIT" "origin/main"; then
            echo "Tag commit is on main."
            exit 0
          fi

          MATCHING_BRANCH=$(git for-each-ref --format='%(refname:short)' refs/remotes/origin \
            | grep -Ei 'origin/.*(beta|alpha|canary|dev)' \
            | while read -r branch; do
                if git merge-base --is-ancestor "$TAG_COMMIT" "$branch"; then
                  echo "$branch"
                  break
                fi
              done)

          note() { echo "$1"; }
          if [ -n "$MATCHING_BRANCH" ]; then
            note "Tag commit is on allowed branch: $MATCHING_BRANCH"
          else
            note "Tag commit is not on main or an allowed branch (beta/alpha/canary/dev)." >&2
            exit 1
          fi

      - name: Check pre-release status
        id: prerelease
        env:
          TAG_NAME: ${{ steps.tag.outputs.tag }}
        run: |
          PRERELEASE_LABEL=""
          if [[ "$TAG_NAME" == *-alpha* ]]; then
            PRERELEASE_LABEL="alpha"
          elif [[ "$TAG_NAME" == *-beta* ]]; then
            PRERELEASE_LABEL="beta"
          elif [[ "$TAG_NAME" == *-rc* ]]; then
            PRERELEASE_LABEL="rc"
          elif [[ "$TAG_NAME" == *-canary* ]]; then
            PRERELEASE_LABEL="canary"
          fi

          if [[ -n "$PRERELEASE_LABEL" ]]; then
            echo "IS_PRERELEASE=true" >> "$GITHUB_OUTPUT"
          else
            echo "IS_PRERELEASE=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Resolve release range
        id: range
        env:
          CURRENT_TAG: ${{ steps.tag.outputs.tag }}
          PRERELEASE: ${{ steps.prerelease.outputs.IS_PRERELEASE }}
          SHALLOW_SINCE: ${{ inputs.shallow_since }}
        run: |
          if [ "$PRERELEASE" = "true" ]; then
            PREVIOUS_TAG=$(git describe --tags --abbrev=0 "${CURRENT_TAG}^" 2>/dev/null || true)
          else
            PREVIOUS_TAG=$(git tag --merged "${CURRENT_TAG}^" --sort=-version:refname \
              | grep -Ev '(-alpha|-beta|-rc|-canary)' \
              | head -n1 || true)
          fi
          if [ -z "$PREVIOUS_TAG" ] && [ -f .git/shallow ] && [ -z "$SHALLOW_SINCE" ]; then
            git fetch origin --tags --unshallow
            if [ "$PRERELEASE" = "true" ]; then
              PREVIOUS_TAG=$(git describe --tags --abbrev=0 "${CURRENT_TAG}^" 2>/dev/null || true)
            else
              PREVIOUS_TAG=$(git tag --merged "${CURRENT_TAG}^" --sort=-version:refname \
                | grep -Ev '(-alpha|-beta|-rc|-canary)' \
                | head -n1 || true)
            fi
          fi
          if [ -n "$PREVIOUS_TAG" ]; then
            PREVIOUS_OID=$(git rev-parse "${PREVIOUS_TAG}^{commit}")
            CURRENT_OID=$(git rev-parse "${CURRENT_TAG}^{commit}")
            RANGE="${PREVIOUS_OID}..${CURRENT_OID}"
          else
            CURRENT_OID=$(git rev-parse "${CURRENT_TAG}^{commit}")
            RANGE="${CURRENT_OID}"
          fi
          echo "previous_tag=$PREVIOUS_TAG" >> "$GITHUB_OUTPUT"
          echo "range=$RANGE" >> "$GITHUB_OUTPUT"

      - name: Generate release notes (pre-release, GitHub default via git-cliff)
        id: prerelease_notes
        if: steps.prerelease.outputs.IS_PRERELEASE == 'true'
        uses: orhun/git-cliff-action@v4
        with:
          config: github
          args: --strip header ${{ steps.range.outputs.range }}
        env:
          GITHUB_REPO: ${{ github.repository }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate release notes (stable, curated aggregate)
        id: stable_notes
        if: steps.prerelease.outputs.IS_PRERELEASE != 'true'
        shell: bash
        env:
          RELEASE_RANGE: ${{ steps.range.outputs.range }}
        run: |
          set -euo pipefail
          # Stable notes are intentionally aggregated from one range pass
          # to avoid canary-style repeated chunks between stable tags.

          mapfile -t COMMITS < <(git log --no-merges --reverse --format='%H%x09%s' "$RELEASE_RANGE")

          if [ "${#COMMITS[@]}" -eq 0 ]; then
            printf -v NOTES '%s\n' \
              "## What's Changed" \
              "" \
              "- No notable changes in this release." \
              "" \
              "### Full Changelog" \
              "- No commits in selected range."
          else
            declare -a GROUP_ORDER=(
              "New Features"
              "Bug Fixes"
              "Performance"
              "Refactors"
              "Documentation"
              "Tests"
              "Build"
              "CI"
              "Chores"
              "Reverts"
              "Other Changes"
            )

            declare -A GROUPED_LINES=()
            declare -a ALL_CHANGES=()

            for line in "${COMMITS[@]}"; do
              SHA="${line%%$'\t'*}"
              SUBJECT="${line#*$'\t'}"
              GROUP="Other Changes"
              DISPLAY="$SUBJECT"

              if [[ "$SUBJECT" =~ ^([[:alpha:]]+)(\(([[:alnum:]./_-]+)\))?:[[:space:]]+(.+)$ ]]; then
                TYPE_LOWER="${BASH_REMATCH[1],,}"
                SCOPE="${BASH_REMATCH[3]:-}"
                MESSAGE="${BASH_REMATCH[4]}"

                case "$TYPE_LOWER" in
                  feat) GROUP="New Features" ;;
                  fix) GROUP="Bug Fixes" ;;
                  perf) GROUP="Performance" ;;
                  refactor) GROUP="Refactors" ;;
                  docs) GROUP="Documentation" ;;
                  test) GROUP="Tests" ;;
                  build) GROUP="Build" ;;
                  ci) GROUP="CI" ;;
                  chore) GROUP="Chores" ;;
                  revert) GROUP="Reverts" ;;
                esac

                if [ -n "$SCOPE" ]; then
                  DISPLAY="**$SCOPE:** $MESSAGE"
                else
                  DISPLAY="$MESSAGE"
                fi
              elif [[ "$SUBJECT" =~ ^Bump[[:space:]] ]]; then
                GROUP="Chores"
              fi

              GROUPED_LINES["$GROUP"]+="- $DISPLAY"$'\n'
              ALL_CHANGES+=("- $SHA $DISPLAY")
            done

            NOTES="## What's Changed"
            for GROUP_NAME in "${GROUP_ORDER[@]}"; do
              BLOCK="${GROUPED_LINES[$GROUP_NAME]-}"
              if [ -n "$BLOCK" ]; then
                NOTES+=$'\n\n'"### $GROUP_NAME"$'\n'"$BLOCK"
              fi
            done

            NOTES+=$'\n\n'"### Full Changelog"
            for CHANGE_LINE in "${ALL_CHANGES[@]}"; do
              NOTES+=$'\n'"$CHANGE_LINE"
            done
          fi

          {
            echo "content<<__RELEASE_NOTES__"
            printf '%s\n' "$NOTES"
            echo "__RELEASE_NOTES__"
          } >> "$GITHUB_OUTPUT"

      - name: Select release notes content
        id: notes
        env:
          IS_PRERELEASE: ${{ steps.prerelease.outputs.IS_PRERELEASE }}
          PRERELEASE_NOTES: ${{ steps.prerelease_notes.outputs.content }}
          STABLE_NOTES: ${{ steps.stable_notes.outputs.content }}
        run: |
          if [ "$IS_PRERELEASE" = "true" ]; then
            SELECTED="$PRERELEASE_NOTES"
          else
            SELECTED="$STABLE_NOTES"
          fi

          {
            echo "content<<__RELEASE_NOTES__"
            printf '%s\n' "$SELECTED"
            echo "__RELEASE_NOTES__"
          } >> "$GITHUB_OUTPUT"

  release:
    runs-on: ubuntu-latest
    needs: notes
    permissions:
      contents: write
    steps:
      - name: Create GitHub release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.notes.outputs.tag }}
          body: ${{ needs.notes.outputs.release_notes }}
          prerelease: ${{ needs.notes.outputs.prerelease == 'true' }}
